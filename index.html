<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <title>BLOCK MAZE</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial; }
    #ui {
      position: absolute;
      top: 40px;
      left: 400px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 30px 20px;
      border-radius: 8px;
    }
    #ai {
      position: absolute;
      top: 40px;
      right: 400px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 20px 40px;
      border-radius: 8px;
    }
    #finishOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    #finishOverlay img {
      max-width: 80%;
      max-height: 80%;
      border-radius: 12px;
      box-shadow: 0 0 30px rgba(255,255,255,0.5);
    }
  </style>
</head>
<body>
  <div id="ui">Waktu : <span id="time">0</span> detik</div>
  <div id="ai">Gerak : 
    <span id=""> <br> W = Atas <br> S = Bawah <br> A = Kiri <br> D = Kanan </span></div>
  <div id="finishOverlay">
    <img src="images/image.png" alt="Finish Image">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  
  <script>
    //SCENE 
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('rgb(162, 243, 242)');

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    //LIGHT
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.6);
    light.position.set(5, 10, 5);
    scene.add(light);

    //FLOOR 
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(20, 20), //untuk atur ukuran dari lantai atau canvasnya
      new THREE.MeshStandardMaterial({ color: 'rgb(234, 459, 224)'  })
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    //BALL (PLAYER)
    const ball = new THREE.Mesh(
      new THREE.SphereGeometry(0.4, 32, 32),
      new THREE.MeshStandardMaterial({ color: 'rgb(234, 0, 0)' }) 
    );
    ball.position.set(-8, 0.4, -8);
    scene.add(ball);

    //MAZE WALLS
    const walls = [];
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 'rgb(19, 157, 26)' });

    function createWall(x, z, w, d) {
      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(w, 1, d),
        wallMaterial
      );
      wall.position.set(x, 0.5, z);
      scene.add(wall);
      walls.push(wall);
    }

    //labirin sederhana
    createWall(-6, -8, 0.6, 4); //tembok 1 (vertikal)
    createWall(-3, -6, 0.6, 4); //tembok 1.2 (vertikal)
    createWall(-1.1, -8, 0.6, 4); //tembok 1.3 (vertikal)
    createWall(1, -5.7, 0.6, 3.9); //tembok 1.4 (vertikal)
    createWall(8.5, -1.3, 0.4, 5.9); //tembok 1.5 (vertikal)
    createWall(-5.7, 1.9, 0.6, 12); //tembok 1.6 (vertikal)
    //vertikal sebelah kiri
    createWall(-7.4, 0, 0.3, 3.4); //tembok 1.7 (vertikal)
    createWall(-8.8, 1.6, 0.3, 3.4); //tembok 1.8 (vertikal)
    createWall(-7, 6.4, 0.2, 3.6); //tembok 1.9 (vertikal)
    createWall(-8.5, 6.7, 0.2, 4.5); //tembok 2 (vertikal)
    createWall(-5.7, 9.5, 0.8, 1); //tembok 2.1 (vertikal)
    //
    //horizontal kanan atas
    createWall(-3.8, -4, 9, 0.5); //tembok 1 (horizontal)
    createWall(2.7, -8, 4, 0.5); //tembok 1.2 (horizontal)
    createWall(5.8, -8, 0.7, 0.5); //tembok 1.2.1 (horizontal)
    createWall(7.3, -8, 0.7, 0.5); //tembok 1.2.2 (horizontal)
    createWall(8.7, -8, 0.7, 0.5); //tembok 1.2.2 (horizontal)
    createWall(6.7, -6, 6.8, 0.5); //tembok 1.3 (horizontal)
    createWall(5.9, -3.6, 5.6, 1.6); //tembok 1.4 (horizontal)
    //
    //horizontal kiri 
    createWall(9, 2.8, 1.7, 0.5); //tembok 1.5 (horizontal)
    createWall(-8.6, -2, 2.7, 0.5); //tembok 1.6 (horizontal)
    createWall(-7.2, 3.1, 3.4, 0.5); //tembok 1.7 (horizontal)
    createWall(-7.7, 8.9, 1.7, 0.2); //tembok 1.8 (horizontal)
    
    //vertikal bagian tengah
    createWall(5.1, 1.2, 0.4, 3.5); //tembok 2.2 (vertikal)
    createWall(-3.5, 6.6, 0.6, 6.7); //tembok 2.3 (vertikal)
    createWall(1.4, 4.2, 0.1, 5); //tembok 2.4 (vertikal)
    createWall(2.5, 5.4, 0.1, 5); //tembok 2.5 (vertikal)
    createWall(2, 0., 0.1, 1); //tembok 2.5.1 (vertikal)
    createWall(3.7, 4.6, 0.1, 3.7); //tembok 2.6 (vertikal)
    createWall(-1.5, 7.8, 1, 2.7); //tembok 2.7 (vertikal)
    createWall(-3.5, 0, 1, 4); //tembok 2.8 (vertikal)

    //horizontal bagian tengah
    createWall(-1.8, 3.3, 4, 0.3); //tembok 2.7 (horizontal)

    //sebelah kanan
    createWall(7.5, 5.1, 1.2, 1.5); //tembok 2.9 (vertikal)
    createWall(4.8, 6.8, 0.1, 1.8); //tembok 3 (vertikal)
    createWall(6, 6, 0.1, 1.4); //tembok 3.1 (vertikal)
    createWall(7, 7.6, 0.6, 1.4); //tembok 3.2 (vertikal)
     createWall(8., 7.2, 1.5, 0.6); //tembok 3.3 (vertikal)


    //tembok mengelilingi arena
    createWall(10.5, 0, 1, 20); //tembok (vertikal) tembok kanan
    createWall(-10.5, 0, 1, 20); //tembok (vertikal) tembok kiri
    createWall(0, 10, 22, 0.2); //tembok (horizontal) tembok bawah
    createWall(0, -10, 22, 0.2); //tembok (horizontal) tembok atas
    
    
    createWall(6.2, 2.9, 2.6, 0.5); //tembok 2.2 (horizontal)
    createWall(2, -2, 6.7, 0.5); //tembok 2.3 (horizontal)
    createWall(-1.5, 0, 1, 0.5); //tembok 2.4 (horizontal)
    createWall(-2.4, 1.7, 1.3, 0.6); //tembok 2.5 (horizontal)
    createWall(1.4, 0.7, 1.3, 0.6); //tembok 2.6 (horizontal)
    createWall(3.6, 0.7, 1.3, 0.6); //tembok 2.7 (horizontal)
    createWall(0.5, -1.5, 1, 1.5); //tembok 2.7.1 (horizontal)
    createWall(2.6, -0.6, 1.3, 0.1); //tembok 2.7.2 (horizontal)
    createWall(-0.3, 1.5, 1, 1); //tembok 2.8 (horizontal)
    createWall(6.2, 4.3, 5, 0.2); //tembok 2.9 (horizontal)
    createWall(9.2, 5.5, 1.3, 0.2); //tembok 3 (horizontal)
    createWall(-1, 5.7, 2.5, 0.1); //tembok 3.1 (horizontal)
    createWall(-0, 6.6, 2.9, 0.2); //tembok 3.2 (horizontal)
    createWall(-1.2, 4.5, 2.9, 0.1); //tembok 3.3 (horizontal)
    createWall(3.5, 9.1, 11, 0.3); //tembok 3.4 (horizontal)
    createWall(3.5, 8, 7, 0.6); //tembok 3.5 (horizontal)

    const finish = new THREE.Mesh(
      new THREE.BoxGeometry(1, 0.2, 1),
      new THREE.MeshStandardMaterial({ color: 'rgb(251, 251, 41)' }) 

    );
    finish.position.set(8, 0.1, 8);
    scene.add(finish);

    // ===== CAMERA =====
    camera.position.set(0, 12, 12);
    camera.lookAt(0, 0, 0);

    // ===== CONTROLS =====
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    // ===== TIMER =====
    let startTime = Date.now();
    const timeEl = document.getElementById('time');

    // ===== GAME LOOP =====
    const ballBox = new THREE.Box3();
    const wallBox = new THREE.Box3();

    function animate() {
      requestAnimationFrame(animate);

      let speed = 0.08;
      let oldPos = ball.position.clone();

      if (keys['w']) ball.position.z -= speed;
      if (keys['s']) ball.position.z += speed;
      if (keys['a']) ball.position.x -= speed;
      if (keys['d']) ball.position.x += speed;

      // Collision sederhana
      ballBox.setFromObject(ball);

        for (let wall of walls) {
        wallBox.setFromObject(wall);

        if (ballBox.intersectsBox(wallBox)) {
            ball.position.copy(oldPos);
            break;
        }
        }


      // Finish check
    if (ball.position.distanceTo(finish.position) < 0.7) {
      document.getElementById('finishOverlay').style.display = 'flex';
      cancelAnimationFrame(animate);
    }
        document.getElementById('finishOverlay').addEventListener('click', () => {
      location.reload();
    });

      // Update timer
      let elapsed = Math.floor((Date.now() - startTime) / 1000);
      timeEl.textContent = elapsed;

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
